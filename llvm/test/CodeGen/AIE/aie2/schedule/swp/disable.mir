# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 4
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2024 Advanced Micro Devices, Inc. or its affiliates

# RUN: llc --mtriple=aie2 -O2 --start-before=pipeliner \
# RUN: --stop-after=machine-scheduler %s -o - | FileCheck %s

--- |
  target triple = "aie2"

  define dso_local i32 @nopragma(ptr nocapture readonly %p, i32 noundef %n) {
  entry:
    br label %for.body

  for.body:
    %i.06 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
    %s.05 = phi i32 [ %or, %for.body ], [ 0, %entry ]
    %p.addr.04 = phi ptr [ %incdec.ptr, %for.body ], [ %p, %entry ]
    %incdec.ptr = getelementptr inbounds i32, ptr %p.addr.04, i20 1
    %cst = xor i32 %i.06, 7
    %0 = load i32, ptr %p.addr.04, align 4
    %xor = xor i32 %0, %cst
    %or = or i32 %xor, %s.05
    %inc = add nuw nsw i32 %i.06, 1
    %exitcond.not = icmp eq i32 %n, %inc
    br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

  for.cond.cleanup:
    ret i32 %or
  }

  define dso_local i32 @pragma(ptr nocapture readonly %p, i32 noundef %n) {
  entry:
    br label %for.body

  for.body:                                         ; preds = %for.body, %entry
    %i.06 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
    %s.05 = phi i32 [ %or, %for.body ], [ 0, %entry ]
    %p.addr.04 = phi ptr [ %incdec.ptr, %for.body ], [ %p, %entry ]
    %incdec.ptr = getelementptr inbounds i32, ptr %p.addr.04, i20 1
    %cst = xor i32 %i.06, 7
    %0 = load i32, ptr %p.addr.04, align 4
    %xor = xor i32 %0, %cst
    %or = or i32 %xor, %s.05
    %inc = add nuw nsw i32 %i.06, 1
    %exitcond.not = icmp eq i32 %n, %inc
    br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !llvm.loop !0

  for.cond.cleanup:                                 ; preds = %for.body
    ret i32 %or
  }

  !0 = distinct !{!0, !1}
  !1 = !{!"llvm.loop.pipeline.disable"}

...
---
name:            nopragma
alignment:       16
exposesReturnsTwice: false
legalized:       true
regBankSelected: true
selected:        true
failedISel:      false
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: nopragma
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $p0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:ep_as_32bit = COPY $p0
  ; CHECK-NEXT:   [[MOV_RLC_imm10_pseudo:%[0-9]+]]:er = MOV_RLC_imm10_pseudo 10
  ; CHECK-NEXT:   [[MOV_RLC_imm10_pseudo1:%[0-9]+]]:er = MOV_RLC_imm10_pseudo 7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.for.body:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   dead [[LDA_dms_lda_pstm_nrm_imm:%[0-9]+]]:er, [[COPY:%[0-9]+]]:ep_as_32bit = LDA_dms_lda_pstm_nrm_imm [[COPY]], 4 :: (load (s32) from %ir.p.addr.04)
  ; CHECK-NEXT:   [[ADD_add_r_ri:%[0-9]+]]:er = nuw nsw ADD_add_r_ri [[MOV_RLC_imm10_pseudo]], -1, implicit-def dead $srcarry
  ; CHECK-NEXT:   PseudoJ_jump_imm %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.for.body:
  ; CHECK-NEXT:   successors: %bb.3(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   dead [[LDA_dms_lda_pstm_nrm_imm1:%[0-9]+]]:er, [[COPY:%[0-9]+]]:ep_as_32bit = LDA_dms_lda_pstm_nrm_imm [[COPY]], 4 :: (load unknown-size from %ir.p.addr.04, align 4)
  ; CHECK-NEXT:   [[ADD_add_r_ri1:%[0-9]+]]:er = nuw nsw ADD_add_r_ri [[ADD_add_r_ri]], -1, implicit-def dead $srcarry
  ; CHECK-NEXT:   PseudoJ_jump_imm %bb.3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3.for.body:
  ; CHECK-NEXT:   successors: %bb.4(0x04000000), %bb.3(0x7c000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[LDA_dms_lda_pstm_nrm_imm2:%[0-9]+]]:er, [[COPY:%[0-9]+]]:ep_as_32bit = LDA_dms_lda_pstm_nrm_imm [[COPY]], 4 :: (load unknown-size from %ir.p.addr.04, align 4)
  ; CHECK-NEXT:   [[ADD_add_r_ri2:%[0-9]+]]:er = nuw nsw ADD_add_r_ri [[ADD_add_r_ri1]], -1, implicit-def dead $srcarry
  ; CHECK-NEXT:   [[XOR:%[0-9]+]]:er = XOR [[ADD_add_r_ri1]], [[MOV_RLC_imm10_pseudo1]]
  ; CHECK-NEXT:   [[ADD_add_r_ri1:%[0-9]+]]:er = COPY [[ADD_add_r_ri2]]
  ; CHECK-NEXT:   PseudoJNZ [[ADD_add_r_ri2]], %bb.3
  ; CHECK-NEXT:   PseudoJ_jump_imm %bb.4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4:
  ; CHECK-NEXT:   successors: %bb.5(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.5:
  ; CHECK-NEXT:   successors: %bb.6(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[XOR1:%[0-9]+]]:er = XOR [[LDA_dms_lda_pstm_nrm_imm2]], [[XOR]]
  ; CHECK-NEXT:   PseudoJ_jump_imm %bb.6
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.6.for.cond.cleanup:
  ; CHECK-NEXT:   $r0 = COPY [[XOR1]]
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit killed $r0
  bb.1.entry:
    successors: %bb.2(0x80000000)
    liveins: $p0, $r1

    %1:ep = COPY $p0
    %2:er = MOV_RLC_imm10_pseudo 10
    %8:er = MOV_RLC_imm10_pseudo 7

  bb.2.for.body:
    successors: %bb.3(0x04000000), %bb.2(0x7c000000)

    %3:er = PHI %13, %bb.2, %2, %bb.1
    %5:ep = PHI %7, %bb.2, %1, %bb.1
    %9:er = XOR %3, %8
    %10:er, %7:ep = LDA_dms_lda_pstm_nrm_imm %5, 4 :: (load (s32) from %ir.p.addr.04)
    %0:er = XOR %10, %9
    %13:er = nuw nsw ADD_add_r_ri %3, -1, implicit-def dead $srcarry
    PseudoJNZ %13, %bb.2

  bb.3.for.cond.cleanup:
    $r0 = COPY %0
    PseudoRET implicit $lr, implicit $r0

...
---
name:            pragma
alignment:       16
exposesReturnsTwice: false
legalized:       true
regBankSelected: true
selected:        true
failedISel:      false
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: pragma
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $p0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:ep_as_32bit = COPY $p0
  ; CHECK-NEXT:   [[MOV_RLC_imm10_pseudo:%[0-9]+]]:er = MOV_RLC_imm10_pseudo 10
  ; CHECK-NEXT:   [[MOV_RLC_imm10_pseudo1:%[0-9]+]]:er = MOV_RLC_imm10_pseudo 7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.for.body:
  ; CHECK-NEXT:   successors: %bb.2(0x04000000), %bb.1(0x7c000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[XOR:%[0-9]+]]:er = XOR [[MOV_RLC_imm10_pseudo]], [[MOV_RLC_imm10_pseudo1]]
  ; CHECK-NEXT:   [[LDA_dms_lda_pstm_nrm_imm:%[0-9]+]]:er, [[COPY:%[0-9]+]]:ep_as_32bit = LDA_dms_lda_pstm_nrm_imm [[COPY]], 4 :: (load (s32) from %ir.p.addr.04)
  ; CHECK-NEXT:   [[XOR1:%[0-9]+]]:er = XOR [[LDA_dms_lda_pstm_nrm_imm]], [[XOR]]
  ; CHECK-NEXT:   [[MOV_RLC_imm10_pseudo:%[0-9]+]]:er = nuw nsw ADD_add_r_ri [[MOV_RLC_imm10_pseudo]], -1, implicit-def dead $srcarry
  ; CHECK-NEXT:   PseudoJNZ [[MOV_RLC_imm10_pseudo]], %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.for.cond.cleanup:
  ; CHECK-NEXT:   $r0 = COPY [[XOR1]]
  ; CHECK-NEXT:   PseudoRET implicit $lr, implicit killed $r0
  bb.1.entry:
    successors: %bb.2(0x80000000)
    liveins: $p0, $r1

    %1:ep = COPY $p0
    %2:er = MOV_RLC_imm10_pseudo 10
    %8:er = MOV_RLC_imm10_pseudo 7

  bb.2.for.body:
    successors: %bb.3(0x04000000), %bb.2(0x7c000000)

    %3:er = PHI %13, %bb.2, %2, %bb.1
    %5:ep = PHI %7, %bb.2, %1, %bb.1
    %9:er = XOR %3, %8
    %10:er, %7:ep = LDA_dms_lda_pstm_nrm_imm %5, 4 :: (load (s32) from %ir.p.addr.04)
    %0:er = XOR %10, %9
    %13:er = nuw nsw ADD_add_r_ri %3, -1, implicit-def dead $srcarry
    PseudoJNZ %13, %bb.2

  bb.3.for.cond.cleanup:
    $r0 = COPY %0
    PseudoRET implicit $lr, implicit $r0

...
